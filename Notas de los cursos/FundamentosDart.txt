### Sobre Dart
    ## Lenguaje de programaci√≥n dado a conocer en octubre de 2011 durante la conferencia goto de Google. ¬øCon qu√© fin? 
    Busca ser una alternativa moderna a JavaScript para programaci√≥n web (y ahora para muchas otras cosas m√°s) y algunas 
    de sus principales caracter√≠sticas son:

        # Utiliza una m√°quina virtual llamada Dart VM (üòâÔ∏è gui√±o a Java).
        # Es multiplataforma, tanto para dispositivos m√≥viles, web, escritorio y dispositivos embebidos.
        # Utiliza un compilador AOT (Ahead-of-Time), caracter√≠stica que consiste en compilar todo el c√≥digo antes de la ejecuci√≥n.
        # Cuenta con hot reload que permite ver los cambios de tu aplicaci√≥n al instante.

    ## Durante la Google IO 2019 que se celebr√≥ el mes de mayo, se hicieron algunos anuncios importantes sobre el framework 
    Flutter, (utiliza Dart como lenguaje de desarrollo). De entrada se mostr√≥ la nueva versi√≥n 1.5, se confirm√≥ la 
    compatibilidad con desarrollo web, escritorio y dispositivos embebidos, uso de ML, etc.

### Tipos de datos

    ## En Dart existen los siguientes tipos de datos:

        # int --> Numeros enteros
        # double --> numeros decimales
        # String --> cadenas de texto
        # bool --> valores booleanos (true o false)
        # dynamic --> Tipos dinamicos


### Declaracion de variables

    ## En Dart todo es un objeto, por lo que la declaraci√≥n de variables como enteros, de punto flotante, booleanos y cadenas
     de texto, son una instancia de objetos de determinado tipo, tan es as√≠ que null, tambi√©n es un objeto üòÆÔ∏è. Otra 
     caracter√≠stica importante es que se permite la inferencia de tipos utilizando la palabra reservada var.

    ## Como se ve en el ejemplo de abajo basta con utilizar la palabra var y el nombre de la variable, o si lo prefieres,
     indicar el nombre del tipo seguido del nombre de la variable.
        # var numero; // Objeto en null
        # var numero2 = 2;
        # int numero3 = 3;

    ## De punto flotante
        # No podemos utilizar expl√≠citamente el tipo float, en su lugar utilizamos el tipo double. A los objetos double se 
        les puede asignar un valor entero, es decir, no hay necesidad de agregar el punto y los valores decimales forzosamente.

        # double decimal= 9.0;
        # double decimal2 = 2; // Equivalente a 2.0

    ## Boolenos
        # Solo se admiten los valores de true y false como valores booleanos.
            # bool verdadero = true;
            # bool falso = false;

    ## Cadenas de texto
        # Podemos utilizar comillas dobles ‚Äú o comillas simples ‚Äò para asignar una cadena de texto.
            # String saludo = "Hola mundo en Dart";
            # String saludo2 = 'Hola mundo en Dart';

        # Tambi√©n podemos hacer interpolaci√≥n de cadenas, basta con agregar dentro de las comillas el 
          signo de $ y el nombre de cualquier variable
            # String saludo = "Hola mundo en Dart";
            # String saludo3 = "$saludo desde otra variable"; // Output: Hola mundo en Dart desde otra variable
        
        # Podemos concatenar de diferentes maneras, podemos utilizar el s√≠mbolo de + para unir dos cadenas o basta con 
          tener un espacio o un salto de l√≠nea entre el par de comillas:
            # String saludo = "Hola mundo" + " a todos";
            # String saludo2 = "Hola mundo" " a todos";
            # String saludo2 = "Hola mundo"
            " a todos";             //Output: Hola mundo a todos

        # Si queremos utilizar saltos de l√≠nea podemos utilizar las triples comillas simples ‚Äò‚Äò‚Äò o dobles ‚Äú ‚Äú ‚Äú.
            # String saludo = '''Saludo con saltos de linea ...
            ... hasta aqu√≠ '''; // La salida respeta los saltos de linea... 

    ## Dynamic 
        # Estas variables pueden tomar cualquier tipo de dato y cambiarlo a cualquier otro en todo momento.
            # dynamic valor = 12;
            # valor = "Cadena de texto";
            # valor = 3.1416;
            # valor = true;

    ## Colecciones
        # Listas: Las variables de tipo lista deben indicar el tipo de elementos que contendr√°, se indica el tipo dentro
         de los s√≠mbolos <> como se ve en ejemplo de abajo, adem√°s, para asignar elementos podemos usar corchetes [] 
        y dentro los elementos a agregar separados por una coma.

                # List<String> list; // Output: null
                # list = ['Juan', 'Ana']; // Output: [Juan, Ana]

            # Podemos agregar m√°s elementos a la lista de la siguiente manera.

                # list.add('Pepe'); // Output: [Juan, Ana, Pepe]

            # Podemos remover elementos de la lista de la siguiente manera.

                # list.removeAt(2); // Output: [Juan, Ana]
                # list.removeLast(); // Output: [Juan]

            # Podemos concatenar dos listas distintas en una sola de la siguiente manera.

                # List<String> list2 = ['Maria', 'Jose']; // Output: [Maria, Jose]
                # list.addAll(list2); // Output: [Juan, Ana, Maria, Jose]

            # Adem√°s, podemos tambi√©n construir un lista con elementos de tipo dynamic, 
            en otras palabras, una lista de cualquier tipo de objetos.

                # List<dynamic> listaDinamica = [1,2,3,4, 'Hola', 3.4, true];

        # Sets: Muy similar a una lista, pueden contener una colecci√≥n de objetos, se diferencian porque los elementos que 
        contiene nunca se repiten. En el ejemplo de abajo al momento de inicializar el Set con el m√©todo from(), se pasa una 
        lista con el elemento ‚ÄòBlanco‚Äô repetido, sin embargo, si imprimimos o accedemos al Set notaremos que solo se encuentra 
        una sola vez.
                # Set colores = Set.from(['Amarillo', 'Blanco', 'Blanco']); // Output: {Amarillo, Blanco}

            # Para agregar elementos al Set usamos:
                # colores.add('Negro'); // Output: {Amarillo, Blanco, Negro}

            # Para concatenar elementos de un Set a otro usamos:
                # Set colores2 = Set.from(['Rojo', 'Azul']);
                # colores.addAll(colores2);  // Output: {Amarillo, Blanco, Azul, Rojo}

            # Para eliminar elementos del Set usamos:
                # colores.remove('Blanco'); // Output: {Amarillo, Azul, Rojo}
                # colores.clear(); // Output: {}

        # Maps: Los mapas son colecciones que se caracterizan por estar compuestas de elementos Clave:Valor. Para inicializar 
        una variable de tipo Map basta con asignar entre llaves {} los v√°lores Clave:Valor separados por una coma.

                # var ciudades = {'Mexico': 'CDMX', 'Argentina': 'Buenos Aires', 'Espa√±a': 'Madrid', 'Colombia':  'Bogota' };

            # Para agregar nuevos elementos al Map usamos.
                
                # ciudades['Chile'] =  'Santiago de Chile';
                # ciudades2 = {'Uruguay':'Montevideo'};
                # ciudades.addAll(ciudades2);

            # Para eliminar un elemento del Map usamos la Clave del elemento a eliminar.

                # ciudades.remove('Espa√±a');
                # ciudades.clear();


### Declaraci√≥n de Constantes
    ## Existen dos formas de crear constantes, la primera es con la palabra reservada const que implica que aloja el valor en 
    tiempo de compilaci√≥n, en contraste con la palabra reservada final, que aloja el valor en la memoria en tiempo de 
    ejecuci√≥n.

        # const NOMBRE = "Pepe";
        # final EDAD = 24;

    ## Tambi√©n puedes crear constantes est√°ticas de clase usando la palabra static antes de const o final.
        # static const NOMBRE = "Pepe";
        # static final EDAD = 24;


### Declaraci√≥n de Funciones
    ## En Dart las funciones tambi√©n son objetos, lo que significa que incluso podemos pasarlas como par√°metros de otras 
    funciones como un objeto de tipo Function.

            # main() {
            # var operacion1 = operacion(5, 3, suma);
            # var operacion2 = operacion(5, 3, resta);
            # print(operacion1); print(operacion2); }

            # int operacion(int a, int b, Function func) { return func(a, b);}
            # int suma(int a, int b) { return a + b; }
            # int resta(int a, int b) { return a - b; }

    ## Tambi√©n podemos escribir las funciones de una forma m√°s abreviada, siempre y cuando sea una sola sentencia a ejecutar,
     por lo que el ejemplo anterior puede escribirse de la siguiente manera:

            # main() {
            # var operacion1 = operacion(5, 3, suma);
            # var operacion2 = operacion(5, 3, resta);
            # print(operacion1);
            # print(operacion2);}

            # int operacion(int a, int b, Function func) => func(a, b);
            # int suma(int a, int b) => a + b;
            # int resta(int a, int b) => a - b;

    ## En Dart podemos utilizar funciones an√≥nimas con la notaci√≥n de flecha:

            #void main() {
            # var resultado = operacion(5, 3, (a, b) => a * b);
            # print(resultado);}

            # int operacion(int a, int b, Function func) => func(a, b);

    ## Par√°metros opcionales posicionados: Permite que uno o varios par√°metros de una funci√≥n sean opcionales al momento de 
    ser llamada dicha funci√≥n. Para indicar los par√°metros opcionales posicionados basta con encerrarlos entre corchetes []. 
    Importante considerar que √∫nicamente puedes usar esta notaci√≥n con el o los √∫ltimos par√°metros dentro de la definici√≥n 
    de par√°metros.

            # main() {
            # infoPersona("Carlos", 24); }
            # // Ejemplo correcto
            # void infoPersona(String nombre, int edad, [String ciudad]) {        
            # print("Descripcion: $nombre con $edad a√±os de $ciudad");}
            # // Ejemplo correcto
            # void infoPersona([String nombre, int edad, String ciudad]) {        
            # print("Descripcion: $nombre con $edad a√±os de $ciudad");}

        # Los siguientes ejemplos no son v√°lidos, debido a que los corchetes [] encierran par√°metros al principio o en 
        medio de la definici√≥n de par√°metros:

            #// Ejemplo incorrecto
            # void infoPersona(String nombre, [int edad], String ciudad) {        
            # print("Descripcion: $nombre con $edad a√±os de $ciudad"); }
            # Ejemplo incorrecto2
            # void infoPersona([String nombre, int edad], String ciudad) {        
            # print("Descripcion: $nombre con $edad a√±os de $ciudad");}

    ## Par√°metros opcionales nombrados: Permite utilizar una etiqueta en la llamada de las funciones. Para indicar los 
    par√°metros opcionales nombrados basta con encerrarlos entre llaves {}. Al igual que los par√°metros opcionales 
    posicionados, solo los √∫ltimos par√°metros pueden utilizar esta caracter√≠stica.

            # main() {
            # infoPersona("Carlos", 24, ciudad: "CDMX"); }

            // Ejemplo correcto
            # void infoPersona(String nombre, int edad, {String ciudad}) {        
            # print("Descripcion: $nombre con $edad a√±os de $ciudad");}

            // Ejemplo correcto 2
            # void infoPersona({String nombre, int edad, String ciudad}) {        
            # print("Descripcion: $nombre con $edad a√±os de $ciudad");}

        # Los siguientes ejemplos no son v√°lidos, debido a que las llaves {} encierran par√°metros al principio o en medio 
        de la definici√≥n de par√°metros:

            # // Ejemplo incorrecto
            # void infoPersona(String nombre, {int edad}, String ciudad) {        
            # print("Descripcion: $nombre con $edad a√±os de $ciudad");}

            // Ejemplo incorrecto 2
            # void infoPersona({String nombre, int edad}, String ciudad) {        
            # print("Descripcion: $nombre con $edad a√±os de $ciudad"); }

    ## Par√°metros con valores por defecto: Al igual que los Par√°metros opcionales nombrados utilizan un par de llaves {} 
       para encerrar los par√°metros con valores por defecto y √∫nicamente los posicionados al final de la definici√≥n de 
       par√°metros pueden ser definidos de esta manera. Para usarlos, despu√©s del nombre de la variable se usa el 
       signo = seguido del valor inicial deseado.

        # main() {
        # infoPersona("Carlos", 24); }

        # void infoPersona(String nombre, int edad, {String ciudad = "CDMX"})  {        
        # print("Descripcion: $nombre con $edad a√±os de $ciudad"); }


### Operaciones condicionales

    ## If-else: La condici√≥n If-Else eval√∫a cierta condici√≥n y ejecuta un bloque c√≥digo en caso de que la condici√≥n sea v√°lida en 
        caso contrario utiliza otro bloque de c√≥digo o incluso puede realizar otra evalaci√≥n anidada.

        # var precio = 500;
        # if (precio  == 500) {
        #   print("Precio promedio");
        # } else if (precio > 500) {
        # print("Precio mayor del promedio");}
        #  else {
        # print("Precio comun");}

    ## Operador ternario: Similar al If-Else pero m√°s abreviado, utiliza una notaci√≥n con el signo de ? seguido de los casos 
    en los que la avaluaci√≥n sea verdadera o falsa separados por el signo de :

        # var precio = 500;
        # var esBarato = precio < 500 ? true : false;

    ## Switch: Eval√∫a una variable seg√∫n diversos casos. Se pueden utilizar etiquetas como continue para saltar a otro caso 
    dentro del switch.

        # switch(number) {
        # case 10:
        #   print("Es un 10!");
        #   continue cien;
        #   break;
        # case 20:
        #   print("Es un 20!");
        #   break;
        # cien: 
        # case 100:
        #   print("Es un 100!");
        #   break;
        # default:
        #   print("Es otro numero!");}


###  Ciclos de control

    ## Ciclo for: Existen diversas formas de utilizar un ciclo for en Dart, ve√°moslo en algunos ejemplos:

        # Imprime una lista del 0 al 9
            # for (int i = 0; i < 10; i++) { print(i); }

        # Recorrer una lista usando la palabra reservada in que toma el valor actual del recorrido de la lista.
            # var lista = ['Uno', 'Dos', 'Tres'];
            # for (String num in lista) { print(num); }

        # Recorrer una lista usando el m√©todo forEach() de la lista con una funci√≥n de flecha.
            # var lista = ['Uno', 'Dos', 'Tres'];
            # lista.forEach((num) => { print(num) });

        # Recorrer una lista usando el m√©todo forEach() de la lista con una funci√≥n an√≥nima.
            # var lista = ['Uno', 'Dos', 'Tres'];
            # lista.forEach((num){print(num);});

    ## Ciclo while: El ciclo while eval√∫a una condici√≥n y si es v√°lida ejecuta un bloque de c√≥digo mientras la condici√≥n 
    siga afirmativa. Por ejemplo, Imprimir una lista del 0 al 9.

        # var num = 0; while (num < 10) { print(num); num++; }

    ## Ciclo do while: El ciclo do while ejecuta un bloque c√≥digo y desp√∫es eval√∫a una condici√≥n que indica si el bloque se 
     sigue ejecutando. Por ejemplo, Imprimir una lista del 0 al 9.

        # var num = 0; do { print(num); num++; } while (num < 10);


### Definici√≥n de Clases

    ## Para escribir una clase se usa la palabra reservada class seguida de llaves y dentro la definici√≥n de miembros y 
    funciones. Por defecto tiene un constructor vac√≠o. Ejemplo sencillo de una clase:

        # class Gato {
        #   var id;
        #   var nombre;
        #    bool dormido(bool estado){
        #       return estado;}           
        # void comer(){
            print("El gato come"); }}


    ## Crear Instancia de una Clase: Podemos utilizar la palabra var o el nombre de la clase seguido del nombre de la 
    instancia, le asignamos la llamada del constructor de la clase Gato con el uso opcional de la palabra new.

        # main() {
        # var gato = new Gato();
        # gato.id = 1;
        # gato.nombre = "Esponjita";
        # gato.dormido(true);
        # gato.comer(); }

    ## El mismo ejemplo pero con nuevas caracter√≠sticas de Dart que permiten que sea m√°s abreviado. Notar que el acceso a 
    las variables y funciones se puede realizar inmediatamente despu√©s del constructor usando

        # var gato = Gato()
        # ..id =1
        # ..nombre = "Esponjita"
        # ..comer()
        # ..dormido(false);

    ## Clase con constructores nombrados: Se utilizan para tener diversos constructores, consiste en escribir el nombre del 
      constructor, punto y un nombre a asignar. Ver el ejemplo abajo de la clase Gato y su constructor nombrado 
      Gato.conBotas(‚Ä¶).

        # class Gato{
        # var id;
        # var nombre;
        # var botas;
        # Gato(int id, String nombre){
        #   this.id = id;
        #   this. nombre = nombre; }
        # Gato.conBotas(int id, String nombre, bool botas){
        #   this.id = id;
        #   this.nombre = nombre;
        #   this.botas = botas;}}

    ## Como alternativa Dart nos ofrece la posibilidad de escribir directamente el nombre de los miembros utilizando la 
    palabra this en la definici√≥n de par√°metros de los constructores, de esta forma evitamos escribir el cuerpo del 
    constructor yreducimos las l√≠neas de c√≥digo necesarias.

        # class Gato{
        #   var id;
        #   var nombre;
        #   var botas;
        #   Gato(this.id, this.nombre);
        #   Gato.conBotas(this.id, this.nombre, this.botas);}

        # Se puede usar de la siguiente manera:
            # main() { var gato = Gato.conBotas(1, "Peko", true); }

    ## Miembros privados: Los miembros privados se declaran con un gui√≥n bajo antes del nombre, por ejemplo: _edad

        # Clase Gato con miembro _edad privado

            # class Gato{ var id; var nombre; var botas; var _edad; }
            # main(){ var gato = Gato() 
            # .._edad = 12; // ERROR 
            # ..print(gato._edad); // ERROR }

    ## Getters y Setters: Cuando declaramos miembros de un clase, Dart encapsula cada uno en sus m√©todos de acceso get y set,
     con la ventaja de que no es perceptible para el desarrollador a simple vista. Sin embargo podemos personalizarlos.

        # Clase Gato utilizando get y set personalizado para acceder al miembro _edad;

            # class Gato{ var id; var nombre; var botas; var _edad;
            # set edad(int edad) { this._edad = edad; }
            # int get edad { return _edad + 2; } }
            # main () {
            # var gato = Gato()
            # ..nombre = "Pako"
            # ..botas = true
            # ..edad = 12; // set
            # print(gato.edad); // get }

        # Getters y Setters abreviados con una funci√≥n de flecha.

            # class Gato{ var id; var nombre; var botas; var _edad;
            # set edad(int edad) => this._edad = edad;
            # int get edad => _edad + 2;}

    ## Herencia: Para heredar de otra clase usamos la palabra extends seguido del nombre de la clase. √önicamente una clase
     puede heredar de una y solo una clase padre.

            # class Animal { var id; var especie; }
            # class Gato extends Animal { var nombre; var botas; habla() => print("Mew"); }

            # main(){ var gato = Gato()
            # ..id = 12
            # ..especie = "Mamifero"
            # ..nombre = "Pako"
            # ..botas = true
            # ..habla(); }

    ## Clases abstractas: Podemos definir clases abstractas, es decir, clases que permiten a sus clases hijas redefinir sus 
    miembros y sus funciones. Basta con agregar la palabra abstract antes de la palabra class y el nombre de la clase.

            # Las funciones definidas pueden o no estar implementadas.
            # Tambi√©n los miembros de la clase padre se redefinen en la clase hija.

        # Las clases hijas heredan de una clase abstracta usando la palabra extends y el nombre de la clase padre.

            # abstract class Animal { var id; var especie;
            # nacer() => print("Naciendo ...");
            # comer(var comida) => print("Comiendo $comida");
            # hablar();}
            # class Gato extends Animal {
            #  var nombre;  var botas;
            #  @override
            #  hablar() => print("Mew");}

        # Un objeto de tipo Gato se puede utilizar as√≠:

            # main() {
            # var gato = Gato()
            # ..id = 12
            # ..especie = "Mamifero"
            # ..nombre = "Pako"
            # ..botas = true
            # ..nacer()
            # ..hablar()
            # ..comer("pescado");}
            
    ## Interfaces: En Dart no existen expl√≠citamente las Interfaces, utilizamos la palabra reservada implements para que 
      una clase sobreescriba la definici√≥n una o m√°s clases.

            # class Animal { var id; var especie;
            # nacer() => print("Naciendo ..."); comer(var comida) => print("Comiendo $comida");}

            # class Gato implements Animal {
            #  @override
            #  var id;
            #  @override
            #  var especie;
            #  var nombre;
            #  var botas;
            #
            #  @override
            #  comer(comida) => print("Comiendo $comida para gato");
            #  @override
            #  nacer() => print("Naciendo de mama gato");}

            # main(){
            # var gato = Gato()
            # ..id = 12
            # ..especie = "Mamifero"
            # ..nombre = "Pako"
            # ..botas = true
            # ..nacer()
            # ..comer("pescado"); }

        # Un truco para simular las interfaces puede ser, usar una clase abstracta que no implemente ninguna funci√≥n dentro 
        de ella.

            # abstract class Animal {
            #   nacer();
            #   comer(var comida);
            #   }

            #   class Gato implements Animal {
            #   var nombre;
            #   var botas;

            #   @override
            #   comer(comida) => print("Comiendo $comida para gato");

            #   @override
            #   nacer() => print("Naciendo de mama gato");
            #   }
            #   main() {
            #   var gato = Gato()
            #   ..nombre = "Pako"
            #   ..botas = true
            #   ..nacer()
            #   ..comer("pescado");
            #   }