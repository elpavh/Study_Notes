### Desarrollo de Apps Multiplataforma con Flower de Google

    ## ¿Qué es Flutter y por qué es útil?
        # lutter permite desarrollar aplicaciones para iOS, Android y web usando un único código base. 
        Sus ventajas principales incluyen:
            # Hot reload: visualiza tus cambios en tiempo real sin necesidad de largas compilaciones.
            # Lenguaje de programación simple: ideal tanto para principiantes como para expertos.
            # Desarrollo modular: basado en widgets que puedes personalizar, configurar y reutilizar.

    ## ¿Cómo se siente programar con Flutter?
        # El proceso se asemeja a construir con bloques de lego. Los widgets actúan como bloques fundamentales para:
            # Diseñar interfaces personalizadas.
            # Reutilizar componentes, lo que ahorra tiempo.
            # Mantener un desarrollo ágil y eficiente.

    ## ¿Qué aplicación puedes crear con Flutter?
        # Un ejemplo práctico es una app de recetas, diseñada para iOS y Android, con las siguientes características:
            # Pantalla principal (Home): lista de recetas obtenida de una API.
            # Favoritos: opción para agregar o eliminar recetas, con actualizaciones instantáneas.
            # Detalle de receta: muestra información específica de cada receta.
            # Formulario validado: permite ingresar y gestionar datos.

    ## ¿Cómo desplegar tu aplicación?
        # Una vez desarrollada, puedes publicar tu app en la Play Store, acercándola a millones de usuarios potenciales.

    ## https://docs.flutter.dev/cookbook

### Programación en Dart: Variables, Funciones y Clases Básicas

    ## En Dart, todo es un objeto y todas las clases heredan de la clase Object, lo que simplifica la estructura y potencia la
     reutilización de código. Aprender cómo manejar variables, constantes, funciones y clases en este lenguaje es fundamental 
     para aprovechar su capacidad en aplicaciones robustas.

    ## ¿Cómo se definen las variables en Dart?

        # Dart permite tipado dinámico con var, aunque también es posible especificar tipos específicos.
        # dynamic se utiliza cuando se espera que el tipo de dato cambie en el futuro.
            # Ejemplo de definición:
                # var nombre = 'Alison';
                # String nombreEspecifico = 'Alison';
                # dynamic variable = 'Alison';
                # variable = 123; // Esto está bien
                # variable = true; // También está bien

    ## ¿Qué diferencias existen entre const y final?

        # const asigna valores en tiempo de compilación y es inmutable.
        # final asigna valores en tiempo de ejecución, útil cuando se desconoce el valor final hasta el momento de la ejecución.
        # Ejemplo de uso:
            # final nombre = 'Daniela';
            # const nickname = 'Dani';

    ## ¿Qué tipos de datos ofrece Dart?

        # Números: Representados por int y double.
            # int x = 10; double y = 20.67;

        # Strings: Permiten cadenas de texto simples y multilínea.
            # String palabra = "texto simple";
            # String multilinea = '''texto
                multilínea''';

        # Booleanos: true o false.
            # bool teGustaDart = true;

        # Listas: Colección de elementos ordenados.
            # var lista = [1, 2, 3];

        # Mapas: Estructura clave-valor.
            # var dias = { 'Lu': 'Lunes', 'Ma': 'Martes' };

    ## ¿Cómo se definen funciones en Dart?
        # Las funciones pueden recibir parámetros y devolver datos específicos. Ejemplo de función básica:
            # void myFunction(param1, param2) {// lógica de la función}
    
        # La función main() es el punto de entrada de una aplicación en Dart.

    ## ¿Qué estructuras de control existen en Dart?
        # Dart soporta estructuras de control como:
            # if y else
            # for y while
            # switch y case // Además, permite el uso de break, continue, y assert para control y validación.

    ## ¿Cómo se manejan las excepciones?
        # Dart permite manejar errores con throw para lanzar excepciones y try-catch para capturarlas:
            # try { // código que puede fallar } catch (e) { // manejar error }

    ## ¿Cómo se crean clases y constructores?
        # Las clases en Dart se definen con class, y pueden tener constructores para inicializar variables.
            # class Point { num x, y; Point(this.x, this.y); }

    ## ¿Qué es la herencia en Dart?
        # Dart permite que una clase herede de otra usando extends.
            # class Television {void turnOn() {...} }
            # class SmartTelevision extends Television {
            #   void turnOn() { super.turnOn(); // logica adicional   }   }
    
    ## ¿Cómo se realiza la sobrescritura de métodos?
        # Dart permite la sobrescritura de métodos heredados usando @override.
            # class SmartTelevision extends Television {
            #   @override
            # void turnOn() {// nueva implementación  } }

    ## ¿Qué es un enum en Dart?
        # enum define un conjunto de constantes con nombre.
            # enum Color { red, green, blue }

    ## Ver mas...
        # https://dart.dev/language
        # https://pub.dev/packages?q=supabase          

    ## Formater: selecciona todo el codigo y da click derecho en donde dice Format Selection, y se selecciona 
       en dar para este caso...                                                                                                                                                                                                    


### Creación de Widgets Stateless en Flutter para Recetario Interactivo

    ## ¿Cómo crear y estructurar un StatelessWidget?

        # Definición de la clase: Crea una nueva clase que extienda de StatelessWidget. Por ejemplo:
            # class RecipeBook extends StatelessWidget {
            # @override
            # Widget build(BuildContext context) {
            # return Scaffold();   } }
            # //Scaffold actúa como una hoja en blanco donde añadimos elementos.

        # Personalización inicial: Añade propiedades clave como:
            # AppBar: para mostrar un título y definir colores.
            # Body: La sección principal de la pantalla donde se colocan los widgets.
            # Drawer: Un menú lateral que se desliza desde el borde izquierdo.
            # BottomNavigationBar: Una barra de navegación en la parte inferior de la pantalla.
            # FloatingActionButton (FAB): Un botón flotante que suele usarse para acciones importantes.
            # SnackBar: Mensajes emergentes que se muestran en la parte inferior de la pantalla.

    ## ¿Cómo personalizar la barra superior con AppBar?
        
        # La barra superior se personaliza utilizando la propiedad AppBar. Ejemplo:
            # return Scaffold(
            #  appBar: AppBar(
            #   title: Text(
            #    'Mi Recetario',
            #    style: TextStyle(color: Colors.white),// TextStyle
            #     ),// text
            #   backgroundColor: Colors.orange,
            #    ), // AppBar
            #    ); // Scafold

            # La propiedad title define el texto visible.
            # TextStyle permite modificar el color, tamaño y estilo del texto.
            # backgroundColor define el color de fondo del AppBar.

    ## ¿Cómo eliminar marcas de depuración y warnings?

        # Eliminar la marca de depuración: Ajusta la propiedad debugShowCheckedModeBanner a false en MaterialApp.

            # return MaterialApp( debugShowCheckedModeBanner: false, home: RecipeBook(), );

            # Ocultar warnings temporales: Si no afectan el desarrollo actual, coméntalos en el archivo analysis_options.yaml con #.
    
    ## ¿Qué buenas prácticas seguir al construir widgets?

        # Define widgets constantes si sus datos no cambiarán:
            # const Text('Constante');
        # Usa la estructura jerárquica de widgets para mantener el código organizado.
        # Personaliza propiedades como colores y estilos para mejorar la experiencia visual.

    ## ¿Cómo probar la implementación en el emulador?
        # Guarda los cambios en el archivo main.dart.
        # Observa en el emulador cómo se reflejan las personalizaciones.
        # Ajusta y mejora según el comportamiento observado.


### Widgets Esenciales en Flutter: Container, Row, Column y Text

    ## Cómo estructurar el cuerpo de tu aplicación en Flutter?
        # Antes de agregar widgets, es esencial formatear el código para visualizar la jerarquía correctamente. Usa un 
          formatter, selecciona Dart y observa la disposición en cascada de los widgets.

        # Inicia con un widget Container. Es una caja flexible que puede contener otros widgets, personalizable con 
        propiedades como:
            # Padding y margin: Para espaciar elementos.
            # Border y color: Para estilos visuales.
            # Box model: Define el diseño y estructura.

    ## ¿Cómo crear tarjetas con información?

        # Usa Container para estructurar las tarjetas:
            # Divide las tarjetas en dos secciones: una para la imagen y otra para el texto.
            # Agrega un widget Row para alinear los elementos horizontalmente.

        # Configura la imagen:
            # Crea un Container con propiedades de tamaño (height y width).
            # Aplica el widget ClipRRect para bordes redondeados con la propiedad borderRadius.

        # Organiza el contenido textual:
            # Utiliza un widget Column para colocar elementos en una disposición vertical.
            # Añade texto con Text, como el nombre de la receta y el autor.
            # Usa un Container con un color (ej. naranja) para añadir una línea separadora decorativa.

    ## ¿Cómo agregar espaciado y adaptabilidad?
        
        # Espaciado: Incorpora SizedBox para separar elementos horizontal o verticalmente según el contexto (width o height). 
        # Adaptabilidad: Implementa MediaQuery para ajustar el tamaño de los widgets según la pantalla del dispositivo, 
        especialmente útil para diseños responsive.

    ## ¿Qué prácticas facilitan el desarrollo en Flutter?

        # Formatea el código constantemente para mantener la jerarquía clara.
        # Experimenta con diferentes widgets como Row, Column y Text para dominar su comportamiento.
        # Utiliza propiedades como MediaQuery para diseños flexibles y adaptables.


### Estructuración y Navegación de Pantallas en Flutter

    ## ¿Cómo estructurar las pantallas de tu aplicación?

        # Crea una carpeta específica: Dentro de tu proyecto, organiza tus pantallas en una nueva carpeta llamada screens.
      
        # Configura una pantalla inicial: Crea un archivo como home_screen.dart para tu pantalla principal.
        
        # Usa la convención UpperCamelCase: Al nombrar clases como HomeScreen, asegúrate de respetar esta convención para 
          mantener la legibilidad.

    ## ¿Cómo mover componentes del main a la pantalla principal?

        # Identifica los componentes existentes: Ubica elementos como contenedores en el archivo principal main.dart.

        # Reubica los widgets al nuevo archivo: Transfiere estos componentes al archivo de la pantalla principal 
          (home_screen.dart), utilizando el widget Scaffold para estructurarlos.

    ## ¿Cómo implementar una barra de navegación con pestañas? 

        # Agrega un AppBar con TabBar: Incluye una barra de navegación inferior (TabBar) dentro de tu AppBar.
        # Configura pestañas iniciales:
            # Usa widgets de Icon para representar visualmente las pestañas.
            # Agrega texto descriptivo con el widget Text.
        # Utiliza un TabBarView: Define un TabBarView para que las pestañas muestren diferentes pantallas.

    ## ¿Cómo solucionar errores al configurar el TabBar?

        # Envuelve el Scaffold con un controlador: Usa el widget DefaultTabController para manejar las pestañas.
        # Configura propiedades adicionales:
            # Ajusta el indicador de la pestaña activa con un color distintivo.
            # Personaliza el texto con colores para estados seleccionados y no seleccionados.
        # Gestiona errores en el emulador: Si surgen problemas al guardar, refresca el proyecto desde la línea final para 
          aplicar cambios correctamente.

    ## ¿Qué más puedes personalizar en tu TabBar?
        # Añade más pestañas: Amplía tu navegación agregando más pantallas al listado de pestañas.
        # Optimiza el diseño:
            # Define un máximo de pestañas visibles.
            # Configura colores consistentes con el tema de tu aplicación.


### Estructuración y Navegación de Pantallas en Flutter resumen

    ## Entendiendo la Estructura de un Proyecto Flutter

        # lib/main.dart: Es el archivo principal donde comienza tu app. Aquí defines la estructura básica de tu aplicación.
        # void main() { runApp(MyApp()); }
        # Carpetas Comunes:
            # android y ios: Contienen los archivos específicos para cada plataforma, como configuraciones de permisos y gradle.
            # pubspec.yaml: Archivo donde defines:
                # Paquetes: Dependencias externas para tu proyecto.
                # Fuentes y Recursos: Como imágenes y fuentes personalizadas.

    ## Widgets Básicos en Flutter: los widgets son bloques fundamentales de construcción en Flutter. Todo lo que ves en 
    pantalla es un widget.
        # Scaffold: La base para crear una pantalla con estructura estándar (AppBar, Body, etc.).
            # Scaffold( appBar: AppBar(title: Text('Mi App')), body: Center(child: Text('Hola Flutter!')), )

        # Container: Un widget versátil para diseño, con propiedades como color, padding, y margin.
            # Container( 
            # padding: EdgeInsets.all(16), 
            # margin: EdgeInsets.all(8), 
            # color: Colors.blue,
            # child: Text('Soy un Container'), )
        
        # Text: Muestra texto en pantalla con personalización.
            # Text( 'Hola Mundo!', style: TextStyle(fontSize: 24, color: Colors.black), )

        # Row y Column: Sirven para organizar widgets horizontal (Row) o verticalmente (Column).
            # Column( mainAxisAlignment: MainAxisAlignment.center, children: [Text('Fila 1'), Text('Fila 2')], )

        # ListView: Para listas desplazables dinámicas o estáticas.
            # ListView( 
            #    children: [
            #    ListTile(title: Text('Elemento 1')), 
            #    ListTile(title: Text('Elemento 2')), ], )

    ##  ¿Qué es el Árbol de Widgets en Flutter?

        # Un árbol de widgets es la representación visual de tu interfaz en Flutter. Los widgets están organizados en 
         una jerarquía donde cada widget es un nodo que puede contener otros widgets. Ejemplo: 
            # MaterialApp └── Scaffold ├── AppBar └── Body └── Center └── Text
            # Cada widget en este árbol se encarga de una parte específica de la pantalla.

        #  Más información sobre el Árbol de Widgets: keepcoding.io


### Creación y Personalización de Widgets en Flutter

    ## ¿Cómo reutilizar widgets en nuestra aplicación?
        # Crea un widget personalizado para las tarjetas, nombrándolo, por ejemplo, ReceipesCart. Este widget debe incluir 
          un BuildContext para heredar las propiedades de la aplicación principal.

        # Incluye la estructura de la tarjeta (como un Container) dentro del widget, asegurándote de usar un return para 
          devolverlo.

        # Una vez definido, puedes usar este widget en cualquier parte de tu pantalla, como en el HomeScreen, y reutilizarlo 
          tantas veces como sea necesario.

    ## ¿Qué ajustes de espaciado y padding se pueden hacer?
        # Utiliza PADDING para ajustar el espaciado alrededor de las tarjetas. Esto puede configurarse con valores 
           predeterminados o personalizados usando propiedades como left, top, right y bottom.

        # Si los elementos dentro de las tarjetas están demasiado juntos, usa widgets como SizedBox para crear separación 
          adicional, por ejemplo:
            # Cuatro píxeles entre el título y el autor.
            # Cuatro píxeles entre el nombre y otros elementos.

    ## ¿Cómo alinear y centrar elementos en una tarjeta?
        # Para alinear verticalmente, usa MainAxisAlignment con valores como center dentro de un widget Column.

        # Para alinear horizontalmente, emplea CrossAxisAlignment configurado como start para que los elementos queden al inicio.

        # Estos ajustes aseguran que los componentes de la tarjeta se vean organizados y equilibrados.

    ## ¿Qué estilos se pueden agregar al texto?
        # Usa la propiedad style en widgets de texto para definir:
            # Tamaño de fuente (fontSize), por ejemplo, 16 puntos.
            # Tipografía personalizada, como Quicksand, importándola desde Google Fonts.

        # Aplica estos estilos de manera consistente en todos los textos de la tarjeta, como en el título y el autor.

    ## ¿Cómo mejorar la apariencia de las tarjetas con contenedores?
        # Añade un BoxDecoration a los Container para personalizar su aspecto:
            # Usa colores temporales como naranja para previsualizar el diseño.
            # Añade bordes redondeados con la propiedad BorderRadius, ajustando su tamaño según sea necesario.

        # Estas propiedades no solo mejoran el diseño, sino que también permiten visualizar dónde irán las imágenes y otros elementos.


### Configuración de Imágenes en Flutter: Uso de Carpeta Assets

    ## ¿Cómo configurar la carpeta de imágenes en Flutter?
        # Accede al archivo pubspec.yaml de tu proyecto.
        # Desplázate hacia el final del archivo hasta la sección de assets.
        # Comenta las indicaciones predeterminadas y agrega una nueva ruta:
            # assets:
            #  - assets/imagenes/
        # Crea una carpeta llamada assets en la raíz de tu proyecto y, dentro de ella, otra llamada imagenes.
        # Guarda tus imágenes dentro de esta carpeta. Ahora puedes acceder a estas imágenes desde cualquier widget de tu proyecto.

    ## ¿Cómo agregar imágenes al recetario?
        # Modifica el widget Container de tu recetario.
        # Cambia la propiedad child para incluir un widget Image.
        # Si usas imágenes desde URLs, utiliza Image.network. Por ejemplo:
            # child: Image.network( 'https://link-a-tu-imagen.com/lasagna.jpg', fit: BoxFit.cover, ),
        # Guarda el archivo y verifica que las imágenes se visualicen correctamente.

    ## ¿Cómo ajustar las imágenes al contenedor?
        # Usa la propiedad fit con el widget BoxFit para definir cómo la imagen se adapta al contenedor
            # Ejemplo: BoxFit.cover hará que la imagen rellene completamente el contenedor ajustándose con un ligero zoom.
        # Otras opciones útiles incluyen
            # BoxFit.contain para mantener las proporciones sin recortar.
            # BoxFit.fill para estirar la imagen y cubrir el espacio.

    ## ¿Cómo organizar y limpiar tu código?
        # Selecciona todo el código y dirígete a la opción View en el editor.
        # Activa la opción Word Wrap o utiliza el atajo Alt + Z para ajustar el texto dentro de la pantalla.
        # Esto mejora la legibilidad y facilita futuras modificaciones.


### Creación de Formularios y Botones Interactivos en Aplicaciones

    ## ¿Cómo implementar un botón con acción personalizada?
        # Usa un Floating Action Button: Este widget se utiliza para acciones principales. Puedes asignarle un 
        'onPressed' que ejecutará una función cuando se presione.
        # Personalización del botón:
            # Color: Define colores que resalten, como un naranja de tu paleta.
            # Íconos: Agrega íconos clicables y coloréales, por ejemplo, en blanco, para diferenciarlos del fondo.

    ##  Código básico:
                        FloatingActionButton(
                        onPressed: () {
                            // Lógica a ejecutar
                        },
                        backgroundColor: Colors.orange,
                        child: Icon(Icons.add, color: Colors.white),
                        ),

    ## ¿Cómo mostrar un formulario en un modal?
        # ShowModalBottomSheet: Permite mostrar un contenedor flotante desde la parte inferior de la pantalla.
        # Configuración inicial: 
            # Altura dinámica: Usa MediaQuery.of(context).size para adaptar el tamaño al ancho de la pantalla.
            # Decoración: Aplica colores, contenedores y texto para estructurar el contenido.

        # Ejemplo:
                            void showModal(BuildContext context) {
                            showModalBottomSheet(
                                context: context,
                                builder: (BuildContext context) {
                                return Container(
                                    height: MediaQuery.of(context).size.height * 0.5,
                                    color: Colors.white,
                                    child: Center(child: Text('Hola, aquí va tu formulario')),
                                );
                                },
                            );
                            }

    ## ¿Cómo estructurar un formulario con campos reutilizables?
        # Crea una clase de formulario: Utiliza un StatelessWidget para estructurar tu formulario.
        # Formulario dinámico:
            # Usa Form con una clave (formKey) para manejar validaciones y control de campos.
            # Estructura los campos en columnas para una alineación vertical.

    ## Ejemplo de formulario básico:

                                class RecipeForm extends StatelessWidget {
                                final _formKey = GlobalKey();

                                @override
                                Widget build(BuildContext context) {
                                    return Padding(
                                    padding: EdgeInsets.all(8.0),
                                    child: Form(
                                        key: _formKey,
                                        child: Column(
                                        crossAxisAlignment: CrossAxisAlignment.start,
                                        children: [
                                            Text('Nueva Receta', style: TextStyle(fontSize: 24, color: Colors.orange)),
                                            SizedBox(height: 16),
                                            buildTextField('Nombre de la receta'),
                                        ],
                                        ),
                                    ),
                                    );
                                }

                                Widget buildTextField(String label) {
                                    return TextFormField(
                                    decoration: InputDecoration(
                                        labelText: label,
                                        labelStyle: TextStyle(color: Colors.orange),
                                        enabledBorder: OutlineInputBorder(
                                        borderRadius: BorderRadius.circular(10),
                                        borderSide: BorderSide(color: Colors.orange, width: 1),
                                        ),
                                        focusedBorder: OutlineInputBorder(
                                        borderRadius: BorderRadius.circular(10),
                                        borderSide: BorderSide(color: Colors.orange, width: 1.5),
                                        ),
                                    ),
                                    );
                                }
                                }


    ##  ¿Cómo personalizar widgets para reutilización?
        # Define widgets específicos: Crea widgets para campos de texto que incluyan estilos y validaciones comunes.
        # Propiedades importantes:
            # label: Texto para identificar el campo.
            # InputDecoration: Define bordes, colores y estilos.
            # BorderRadius: Redondea los bordes para un diseño más moderno.

    ## Widget de campo reutilizable:

                    Widget buildCustomTextField(String label, String fontFamily) {
                    return TextFormField(
                        decoration: InputDecoration(
                        labelText: label,
                        labelStyle: TextStyle(fontFamily: fontFamily, color: Colors.orange),
                        enabledBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(10),
                            borderSide: BorderSide(color: Colors.orange, width: 1),
                        ),
                        focusedBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(10),
                            borderSide: BorderSide(color: Colors.orange, width: 1.5),
                        ),
                        ),
                    );
                    }

        # Agrega campos al formulario:
                            Column(
                            children: [
                                buildCustomTextField('Nombre del autor', 'QuickSand'),
                                SizedBox(height: 16),
                                buildCustomTextField('Ingredientes', 'QuickSand'),
                                SizedBox(height: 16),
                                buildCustomTextField('Imagen URL', 'QuickSand'),
                            ],
                            )



### Controladores y Validación de Formularios en Flutter

    ## ¿Cómo añadir campos personalizados al formulario?
        # Los campos requeridos son: nombre, autor, URL de imagen y descripción de la receta.
        # Para cada campo, se utiliza un TextEditingController que permite capturar y almacenar los datos ingresados.
        # La estructura base incluye etiquetas (label) y controladores asignados de manera única para cada campo.

    ## ¿Cómo implementar validaciones en los formularios?
        # Se usa un GlobalKey<FormState> para manejar el estado del formulario.
        # Los validadores son funciones asociadas a cada campo, verificando si este está vacío o contiene datos incorrectos.
        # Ejemplo de validación:
            # Si el campo de nombre está vacío, se muestra el mensaje: “Introduzca el nombre de la receta”.
            # En caso contrario, la validación pasa y el formulario continúa.

    ## ¿Cómo se conecta la validación con los controladores?
        # Cada campo del formulario recibe su propio controlador y validador.
        # La integración de los validadores requiere modificar la widget personalizada, añadiendo parámetros como:
            # validator: para recibir la función de validación.
            # maxLines: para definir el número máximo de líneas en campos como la descripción.

    ## ¿Cómo crear un botón funcional y estilizado?
        # Un botón centrado, implementado con ElevatedButton, maneja el envío del formulario.
        # Antes de procesar la información, se valida que todos los campos estén llenos.
        # En caso de éxito, el formulario se cierra con Navigator.pop.
        # Estilo del botón:
            # Color de fondo, tipografía en negrita y bordes redondeados.
            # Texto descriptivo como “Guardar receta”.

    ## ¿Cómo gestionar los campos con múltiples líneas?
        # Se agrega una variable opcional maxLines para manejar campos que requieran varias líneas, como la descripción de la receta.
        # Esto permite ajustar dinámicamente la cantidad de texto visible en el formulario.

    ## ¿Cómo verificar que las validaciones funcionan correctamente?
        # Al probar el formulario, los campos vacíos generan mensajes de error específicos.
        # Por ejemplo, si no se completa la URL de imagen, se solicita rellenar dicho campo antes de enviar.